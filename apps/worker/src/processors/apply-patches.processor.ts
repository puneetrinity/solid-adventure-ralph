import { Inject, Logger } from '@nestjs/common';
import { Processor, WorkerHost } from '@nestjs/bullmq';
import { InjectQueue } from '@nestjs/bullmq';
import type { Job, Queue } from 'bullmq';
import { getPrisma } from '@arch-orchestrator/db';
import { WriteGate, RunRecorder, type GitHubClient } from '@arch-orchestrator/core';
import { GITHUB_CLIENT_TOKEN } from '../constants';

@Processor('apply_patches')
export class ApplyPatchesProcessor extends WorkerHost {
  private prisma = getPrisma();
  private runRecorder = new RunRecorder(this.prisma);
  private readonly logger = new Logger(ApplyPatchesProcessor.name);

  constructor(
    @Inject(GITHUB_CLIENT_TOKEN) private readonly github: GitHubClient,
    @InjectQueue('workflow') private readonly workflowQueue: Queue
  ) {
    super();
  }

  async process(job: Job<{ workflowId: string; patchSetId: string }>) {
    const { workflowId, patchSetId } = job.data;

    // Get workflow with repo info
    const workflow = await this.prisma.workflow.findUnique({
      where: { id: workflowId }
    });

    if (!workflow) {
      throw new Error(`Workflow ${workflowId} not found`);
    }

    if (!workflow.repoOwner || !workflow.repoName) {
      throw new Error(`Workflow ${workflowId} missing repository configuration`);
    }

    // Get the patch set with patches
    const patchSet = await this.prisma.patchSet.findUnique({
      where: { id: patchSetId },
      include: { patches: true }
    });

    if (!patchSet) {
      throw new Error(`PatchSet ${patchSetId} not found`);
    }

    this.logger.log(`Applying patches for ${workflow.repoOwner}/${workflow.repoName}`);

    // Record run start
    const runId = await this.runRecorder.startRun({
      workflowId,
      jobName: 'apply_patches',
      inputs: { workflowId, patchSetId }
    });

    const writeGate = new WriteGate(this.prisma, this.github);
    const branchName = `bot/workflow-${workflowId.substring(0, 8)}`;

    try {
      // Get base branch SHA
      const baseBranch = await this.github.getBranch({
        owner: workflow.repoOwner,
        repo: workflow.repoName,
        branch: workflow.baseBranch
      });

      // Create feature branch
      this.logger.log(`Creating branch ${branchName} from ${workflow.baseBranch}`);
      await this.github.createBranch({
        owner: workflow.repoOwner,
        repo: workflow.repoName,
        branch: branchName,
        sha: baseBranch.sha
      });

      // Apply each patch by updating files
      for (const patch of patchSet.patches) {
        const files = patch.files as { path: string }[];
        for (const file of files) {
          // For now, we'll create a placeholder file update
          // In a real implementation, we'd parse the diff and apply it
          this.logger.log(`Would apply diff to ${file.path}`);
        }
      }

      // Open PR
      const pr = await writeGate.openPullRequest(workflowId, {
        owner: workflow.repoOwner,
        repo: workflow.repoName,
        head: branchName,
        base: workflow.baseBranch,
        title: patchSet.title || `Workflow ${workflowId.substring(0, 8)}`,
        body: `## Changes\n\n${patchSet.patches.map(p => `- ${p.title}: ${p.summary}`).join('\n')}\n\n---\n*Generated by arch-orchestrator*`
      });

      await this.prisma.pullRequest.create({
        data: {
          workflowId,
          number: pr.number,
          url: pr.url,
          branch: branchName,
          status: 'open'
        }
      });

      await this.prisma.workflowEvent.create({
        data: {
          workflowId,
          type: 'worker.apply_patches.opened_pr',
          payload: { patchSetId, pr }
        }
      });

      // Record run completion
      await this.runRecorder.completeRun({
        runId,
        outputs: { pr, prNumber: pr.number }
      });

      // REFACTORED: Emit success event to orchestrator instead of setting state directly
      await this.workflowQueue.add('orchestrate', {
        workflowId,
        event: {
          type: 'E_JOB_COMPLETED',
          stage: 'apply_patches',
          result: { pr, prNumber: pr.number }
        }
      });

      return { ok: true, pr };
    } catch (err: any) {
      // Record run failure
      await this.runRecorder.failRun({
        runId,
        errorMsg: String(err?.message ?? err)
      });
      await this.prisma.workflowEvent.create({
        data: {
          workflowId,
          type: 'worker.apply_patches.blocked',
          payload: { patchSetId, error: String(err?.message ?? err) }
        }
      });

      // REFACTORED: Emit failure event to orchestrator instead of setting state directly
      await this.workflowQueue.add('orchestrate', {
        workflowId,
        event: {
          type: 'E_JOB_FAILED',
          stage: 'apply_patches',
          error: String(err?.message ?? err)
        }
      });

      return { ok: false, error: String(err?.message ?? err) };
    }
  }
}
